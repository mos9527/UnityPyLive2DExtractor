"""Simple codegen for typetree classes

limitations:
- untested with Namespace references outside its own scope
"""

# From https://github.com/K0lb3/UnityPy/blob/master/generators/ClassesGenerator.py
BASE_TYPE_MAP = {
    "char": "str",
    "short": "int",
    "int": "int",
    "long long": "int",
    "unsigned short": "int",
    "unsigned int": "int",
    "unsigned long long": "int",
    "UInt8": "int",
    "UInt16": "int",
    "UInt32": "int",
    "UInt64": "int",
    "SInt8": "int",
    "SInt16": "int",
    "SInt32": "int",
    "SInt64": "int",
    "Type*": "int",
    "FileSize": "int",
    "float": "float",
    "double": "float",
    "bool": "bool",
    "string": "str",
    "TypelessData": "bytes",
    # -- Extra
    "Byte[]": "bytes",
    "Byte": "int",
    "String": "str",
    "Int32": "int",
    "Single": "float",
    "Color": "ColorRGBA",
    "Vector2": "Vector2f",
    "Vector3": "Vector3f",
    "Vector4": "Vector4f",
}
# XXX: Can't use attrs here since subclassing MonoBehavior and such - though defined by the typetree dump
# seem to be only valid if the class isn't a property of another class
# In which case the MonoBehavior attributes are inherited by the parent class and does not
# initialize the property class
# XXX: Need some boilerplate to handle this
HEADER = "\n".join(
    [
        "# fmt: off",
        "# Auto-generated by https://github.com/mos9527/UnityPyLive2DExtractor/tree/main/UnityPyLive2DExtractor/typetree_codegen.py",
        "" "from typing import List, Union, Optional, TypeVar",
        "from UnityPy.classes import *",
        "from UnityPy.classes.math import (ColorRGBA, Matrix3x4f, Matrix4x4f, Quaternionf, Vector2f, Vector3f, Vector4f, float3, float4,)",
        '''T = TypeVar("T")
def typetree_defined(clazz : T) -> T:
	"""dataclass-like decorator for typetree classess with nested type support
	
	limitations:
	- the behavior is similar to slotted dataclasses where shared attributes are inherited
	  but allows ommiting init of the parent if kwargs are not sufficient
	- generally supports nested types, however untested and could be slow	
    - and ofc, zero type checking and safeguards :/	
	"""
	def __init__(cls, **d):		
		for __base__ in clazz.__bases__:
			types : dict = __base__.__annotations__
			args = {k:d[k] for k in types if k in d}
			if len(args) == len(types):
				super(clazz, cls).__init__(**args)
				for k in args: del d[k]
		types : dict = clazz.__annotations__
		for k, sub in types.items():
			reduce_arg = getattr(sub, "__args__", [None])[0]
			if isinstance(d[k], list) and hasattr(reduce_arg, "__annotations__"):
				setattr(cls, k, [reduce_arg(**x) for x in d[k]])
			elif isinstance(d[k], dict) and hasattr(sub, "__annotations__"):
				setattr(cls, k, sub(**d[k]))
			else:
				if isinstance(d[k], dict):
					setattr(cls, k, sub(**d[k]))
				else:
					setattr(cls, k, sub(d[k]))
	def __repr__(self) -> str:
		return f"{clazz.__name__}({', '.join([f'{k}={getattr(self, k)!r}' for k in self.__annotations__])})"
	clazz.__init__ = __init__
	clazz.__repr__ = __repr__
	return clazz
''',
    ]
)
from collections import defaultdict
import argparse, json


def translate_name(m_Name: str, **kwargs):
    m_Name = m_Name.replace("<>", "__generic_")  # Generic templates
    m_Name = m_Name.replace("<", "_").replace(">", "_")  # Templated
    return m_Name


from UnityPy import classes
from logging import getLogger
from coloredlogs import install

logger = getLogger("codegen")


def translate_type(
    m_Type: str, strip=False, fallback=True, typenames: dict = dict(), **kwargs
):
    if m_Type in BASE_TYPE_MAP:
        return BASE_TYPE_MAP[m_Type]
    if getattr(classes, m_Type, None):
        return m_Type
    if m_Type in typenames:
        return m_Type
    if m_Type.endswith("[]"):
        m_Type = translate_type(m_Type[:-2], strip, fallback, typenames)
        if not strip:
            return f"List[{m_Type}]"
        else:
            return m_Type
    if m_Type.startswith("PPtr<"):
        m_Type = translate_type(m_Type[5:-1], strip, fallback, typenames)
        if not strip:
            return f"PPtr[{m_Type}]"
        else:
            return m_Type
    if fallback:
        logger.warning(f"Unknown type {m_Type}, using fallback")
        return "object"
    else:
        return m_Type


def declare_field(name: str, type: str, org_type: str = None):
    if type not in {"object", "List[object]", "PPtr[object]"}:
        return f"{name} : {type}"
    else:
        return f"{name} : {type} # XXX: Fallback of {org_type}"


from io import TextIOWrapper


def topsort(graph: dict):
    # Sort the keys in topological order
    # We don't assume the guarantee otherwise
    graph = {k: list(sorted(v)) for k, v in graph.items()}
    vis = defaultdict(lambda: 0)
    topo = list()

    def dfs(u):
        vis[u] = 1
        for v in graph.get(u, []):
            if vis[v] == 1:
                return False
            if vis[v] == 0 and not dfs(v):
                return False
        vis[u] = 2
        topo.append(u)
        return True

    for clazz in graph:
        if not vis[clazz]:
            dfs(clazz)

    return topo


def process_namespace(
    namespace: str,
    typetree_defs: dict,
    f: TextIOWrapper,
    import_root: str = "",
    import_defs: dict = dict(),
):
    def emit_line(*lines: str):
        for line in lines:
            f.write(line)
            f.write("\n")
        if not lines:
            f.write("\n")

    namespace = namespace or "<default namespace>"
    logger.info(f"Subpass 1: Generating class dependency graph for {namespace}")
    emit_line("# Auto-generated by UnityPyLive2DExtractor/typetree_codegen.py")
    emit_line(f"# Python definition for {namespace}", "")
    if import_root:
        emit_line(f"from {import_root} import *")
    for clazz, parent in import_defs.items():
        emit_line(f"from {import_root}{parent} import {clazz}")

    emit_line()
    # Emit by topo order
    graph = {
        clazz: {
            translate_type(field["m_Type"], strip=True, fallback=False)
            for field in fields
            # Don't care about built-ins
        }
        for clazz, fields in typetree_defs.items()
    }
    topo = topsort(graph)
    clazzes = list()

    logger.info(f"Subpass 2: Generating code for {namespace}")
    dp = defaultdict(lambda: -1)
    for clazz in topo:
        fields = typetree_defs.get(clazz, None)
        if not fields:
            logger.debug(
                f"Class {clazz} has no fields defined in TypeTree dump, skipped"
            )
            continue
        # Heuristic: If there is a lvl1 field, it's a subclass
        lvl1 = list(filter(lambda field: field["m_Level"] == 1, fields))
        clazz = translate_name(clazz)
        clazzes.append(clazz)
        clazz_fields = list()
        emit_line(f"@typetree_defined")
        if lvl1:
            parent = translate_type(fields[0]["m_Type"], strip=True, fallback=False)
            emit_line(f"class {clazz}({parent}):")
            # Generated typedefs are guaranteed to be flat in hierarchy
            # Recursive ones are defined by previous/topo order
            if dp[parent] == -1:
                # Reuse parent's fields with best possible effort
                # This is a heuristic and may not be correct
                if pa_dep1 := getattr(classes, parent, None):
                    dp[parent] = len(pa_dep1.__annotations__)
                else:
                    raise RecursionError("Circular inheritance detected")
            pa_dep1 = dp[parent]
            cur_dep1 = 0
            for i, field in enumerate(
                filter(lambda field: field["m_Level"] == 1, fields)
            ):
                if i < pa_dep1:
                    # Skip parent fields at lvl1
                    continue
                name, type = field["m_Name"], translate_type(
                    field["m_Type"], typenames=typetree_defs | import_defs
                )
                emit_line(f"\t{declare_field(name, type, field["m_Type"])}")
                clazz_fields.append((name, type, field["m_Type"]))
                cur_dep1 += 1
            dp[clazz] = cur_dep1
        else:
            # No inheritance
            emit_line(f"class {clazz}:")
            for field in fields:
                name, type = field["m_Name"], translate_type(
                    field["m_Type"], typenames=typetree_defs | import_defs
                )
                emit_line(f"\t{declare_field(name, type, field["m_Type"])}")
                clazz_fields.append((name, type))
        if not clazz_fields:
            # Empty class. Consider MRO
            emit_line("\tpass")


import os, shutil
from typing import Dict


def __main__():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "infile",
        type=str,
        help="Input file. Dump with https://github.com/K0lb3/TypeTreeGenerator",
    )
    parser.add_argument("outdir", type=str, help="Output directory")
    parser.add_argument("--log-level", default="INFO", help="Set logging level")
    args = parser.parse_args()
    install(level=args.log_level)

    shutil.rmtree(args.outdir, ignore_errors=True)
    logger.info(f"Reading from {args.infile}")
    TYPETREE_DEFS = json.load(open(args.infile, "r"))
    namespaces = defaultdict(dict)
    namespacesT = defaultdict(None)
    logger.info("Pass 1: Building namespace")
    for key in TYPETREE_DEFS:
        fullkey = key.split(".")
        if len(fullkey) == 1:
            namespace, clazz = None, fullkey[0]
        else:
            namespace, clazz = fullkey[:-1], fullkey[-1]
            namespace = ".".join(namespace)
        namespaces[namespace][clazz] = TYPETREE_DEFS[key]
        if clazz not in namespacesT:
            namespacesT[clazz] = namespace
        else:
            logger.error(
                f"Class {clazz} already defined in {namespacesT[clazz]} but found again in {namespace}"
            )
            logger.error(
                f"Need manual intervention to resolve the conflict. Using first definition for now."
            )
    logger.info("Pass 2: Generating import graph")
    # Build import graph
    namespaceDeps = defaultdict(set)
    for namespace, typetree_defs in namespaces.items():
        for clazz, fields in typetree_defs.items():
            for field in fields:
                type = translate_type(field["m_Type"], strip=True, fallback=False)
                if type in namespacesT and namespacesT[type] != namespace:
                    namespaceDeps[namespace].add(type)
    handles: Dict[str, TextIOWrapper] = dict()

    def __open(fname: str):
        fname = os.path.join(args.outdir, fname)
        if fname not in handles:
            os.makedirs(os.path.dirname(fname), exist_ok=True)
            handles[fname] = open(fname, "w")
        return handles[fname]

    logger.info("Pass 3: Emitting namespace as Python modules")
    __open("__init__.py").write(HEADER)
    # XXX: This part can be trivally parallelized
    for namespace, typetree_defs in sorted(
        namespaces.items(), key=lambda x: x[0].count(".") if x[0] else 0
    ):
        # CubismTaskHandler -> generated/__init__.py
        # Live2D.Cubism.Core.CubismMoc -> generated/Live2D/Cubism/Core.py
        if namespace:
            ndots = namespace.count(".") + 1
            dotss = "." * ndots
            fname = os.path.join(*namespace.split("."))
            f = __open(f"{fname}.py")
            deps = {k: namespacesT[k] for k in namespaceDeps[namespace]}
            deps = dict(sorted(deps.items()))
            process_namespace(namespace, typetree_defs, f, dotss, deps)
        else:
            f = __open("__init__.py")
            process_namespace(namespace, typetree_defs, f)
    __open("__init__.py").write(
        "\nTYPETREE_DEFS = " + json.dumps(TYPETREE_DEFS, indent=4)
    )
    logger.info("All done. Going home.")


if __name__ == "__main__":
    __main__()
